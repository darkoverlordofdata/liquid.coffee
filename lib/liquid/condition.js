// Generated by CoffeeScript 1.11.1
(function() {
  var Liquid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Liquid = require('../liquid');

  Liquid.Condition = (function() {
    var compact;

    compact = require('./util').compact;

    Condition.operators = {
      "==": function(l, r) {
        return l === r;
      },
      "=": function(l, r) {
        return l === r;
      },
      "!=": function(l, r) {
        return l !== r;
      },
      "<>": function(l, r) {
        return l !== r;
      },
      "<": function(l, r) {
        return l < r;
      },
      ">": function(l, r) {
        return l > r;
      },
      "<=": function(l, r) {
        return l <= r;
      },
      ">=": function(l, r) {
        return l >= r;
      },
      contains: function(l, r) {
        return l.match(r);
      },
      hasKey: function(l, r) {
        return l[r] != null;
      },
      hasValue: function(l, r) {
        var p;
        for (p in l) {
          if (l[p] === r) {
            return true;
          }
        }
        return false;
      }
    };

    function Condition(left1, operator, right1) {
      this.left = left1;
      this.operator = operator;
      this.right = right1;
      this.childRelation = null;
      this.childCondition = null;
      this.attachment = null;
    }

    Condition.prototype.evaluate = function(context) {
      var result;
      if (context == null) {
        context = new Liquid.Context;
      }
      result = this.interpretCondition(this.left, this.right, this.operator, context);
      switch (this.childRelation) {
        case "or":
          return result || this.childCondition.evaluate(context);
        case "and":
          return result && this.childCondition.evaluate(context);
        default:
          return result;
      }
    };

    Condition.prototype.or = function(condition) {
      this.childRelation = "or";
      return this.childCondition = condition;
    };

    Condition.prototype.and = function(condition) {
      this.childRelation = "and";
      return this.childCondition = condition;
    };

    Condition.prototype.attach = function(attachment) {
      return this.attachment = attachment;
    };

    Condition.prototype["else"] = function() {
      return false;
    };

    Condition.prototype.toString = function() {
      return "#<Condition " + (compact([this.left, this.operator, this.right]).join(' ')) + ">";
    };

    Condition.prototype.interpretCondition = function(left, right, op, context) {
      var operation;
      if (op == null) {
        return context.get(left);
      }
      left = context.get(left);
      right = context.get(right);
      operation = Condition.operators[op] || new Liquid.ArgumentError("Unknown operator " + op);
      if (operation.call != null) {
        return operation.call(this, left, right);
      } else {
        return null;
      }
    };

    return Condition;

  })();

  Liquid.ElseCondition = (function(superClass) {
    extend(ElseCondition, superClass);

    function ElseCondition() {
      return ElseCondition.__super__.constructor.apply(this, arguments);
    }

    ElseCondition.prototype["else"] = function() {
      return true;
    };

    ElseCondition.prototype.evaluate = function(context) {
      return true;
    };

    return ElseCondition;

  })(Liquid.Condition);

}).call(this);
