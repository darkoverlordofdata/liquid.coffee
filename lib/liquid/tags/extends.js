// Generated by CoffeeScript 1.11.1
(function() {
  var Liquid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Liquid = require('../../liquid');

  Liquid.Tags.Extends = (function(superClass) {
    var ContentOfVariable, FullToken, IsTag, IsVariable, Syntax;

    extend(Extends, superClass);

    Syntax = RegExp("(" + Liquid.QuotedFragment.source + ")");

    IsTag = RegExp("^" + Liquid.TagStart.source);

    IsVariable = RegExp("^" + Liquid.VariableStart.source);

    FullToken = RegExp("^" + Liquid.TagStart.source + "\\s*(\\w+)\\s*(.*)?" + Liquid.TagEnd.source + "$");

    ContentOfVariable = RegExp("^" + Liquid.VariableStart.source + "(.*)" + Liquid.VariableEnd.source + "$");

    function Extends(tagName, markup, tokens) {
      var $, i, len, m, node, ref;
      if (($ = markup.match(Syntax))) {
        this.templateName = $[1];
      } else {
        throw new Liquid.SyntaxError("Syntax Error in 'extends' - Valid syntax: extends [template]");
      }
      Extends.__super__.constructor.apply(this, arguments);
      m = {};
      ref = this.nodelist;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        if (node instanceof Liquid.Tags.Block) {
          m[node.name] = node;
        }
      }
      this.blocks = m;
    }

    Extends.prototype.parse = function(tokens) {
      return this.parseAll(tokens);
    };

    Extends.prototype.render = function(context) {
      var block, name, parentBlocks, pb, ref, template;
      template = this.loadTemplate(context);
      parentBlocks = this.findBlocks(template.root);
      ref = this.blocks;
      for (name in ref) {
        block = ref[name];
        if ((pb = parentBlocks[name]) != null) {
          pb.parent = block.parent;
          pb.addParent(pb.nodelist);
          pb.nodelist = block.nodelist;
        } else {
          if (this.isExtending(template)) {
            template.root.nodelist.push(block);
          }
        }
      }
      return template.render(context);
    };

    Extends.prototype.parseAll = function(tokens) {
      var $, results, tag, token;
      this.nodelist || (this.nodelist = []);
      this.nodelist.length = 0;
      results = [];
      while ((token = tokens.shift()) != null) {
        if (IsTag.test(token)) {
          if (($ = token.match(FullToken))) {
            if (tag = Liquid.Template.tags[$[1]]) {
              results.push(this.nodelist.push(new tag($[1], $[2], tokens)));
            } else {
              results.push(this.unknownTag($[1], $[2], tokens));
            }
          } else {
            throw new Liquid.SyntaxError("Tag '" + token + "' was not properly terminated with regexp: " + TagEnd.inspect + " ");
          }
        } else if (IsVariable.test(token)) {
          results.push(this.nodelist.push(this.createVariable(token)));
        } else if (token === '') {

        } else {
          results.push(this.nodelist.push(token));
        }
      }
      return results;
    };

    Extends.prototype.loadTemplate = function(context) {
      var source;
      source = Liquid.Template.fileSystem.readTemplateFile(context.get(this.templateName));
      return Liquid.Template.parse(source);
    };

    Extends.prototype.findBlocks = function(node, blocks) {
      var b, i, len, ref;
      if (blocks == null) {
        blocks = {};
      }
      if (node.nodelist != null) {
        b = blocks;
        ref = node.nodelist;
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          if (node instanceof Liquid.Tags.Block) {
            b[node.name] = node;
          } else {
            this.findBlocks(node, b);
          }
          b;
        }
      }
      return blocks;
    };

    Extends.prototype.isExtending = function(template) {
      var i, len, node, ref;
      ref = template.root.nodelist;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        if (node instanceof Extends) {
          return true;
        }
      }
      return false;
    };

    return Extends;

  })(Liquid.Block);

  Liquid.Template.registerTag("extends", Liquid.Tags.Extends);

}).call(this);
